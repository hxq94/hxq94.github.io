---
title: NIO
thumbnail:  /img/nio-RoundCorner.png
cover: /img/nio.jpg
categories: 
- java
- 网络编程
tags: 网络编程
toc: true
---
上一篇说过了基础IO流的操作，这篇简单说一下网络编程，网络编程就我自己理解就是在网络世界中进行数据的互相传递，它基于OSI七层模型，进行层层封装，来将数据最终封装成了一个个数据包，然后发往另外一端，这篇暂时不说TCP、UDP以及socket通信的其它协议，这篇只说一下跟IO相关的网络编程
<!--more-->
### 直接上栗子
#### 最简单的IO
一个简单的基于IO的网络编程🌰
```java
// Server
package com.hyf.demo.bio;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketAddress;

public class Server {

    public static void main(String[] args) {


        // 创建连接
        try {
            ServerSocket serverSocket = new ServerSocket();
            SocketAddress socketAddress = new InetSocketAddress("localhost", 9999);
            serverSocket.bind(socketAddress);
            System.out.println("等待客户端连接");
            // 1.这里会等待客户端连接阻塞
            Socket socket = serverSocket.accept();
            System.out.println("客户端连接成功");

            // 读取socket输入流中的数据
            BufferedReader inputStream = new BufferedReader(new InputStreamReader(socket.getInputStream()));

            String msg;
            // 2. 这里会阻塞等待客户端消息
            while ((msg = inputStream.readLine()) != null) {
                System.out.println(msg);
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

// Client
package com.hyf.demo.bio;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.SocketAddress;

public class Client {

    public static void main(String[] args) {

        // 创建socket
        Socket socket = new Socket();
        SocketAddress socketAddress = new InetSocketAddress("localhost", 9999);
        try {
            socket.connect(socketAddress);
            System.out.println("连接服务端成功");

            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));

            String msg;
            // 这里会等待控制台输入 阻塞
            while ((msg = bufferedReader.readLine()) != null) {
                OutputStream outputStream = socket.getOutputStream();
                // 使用了readline 需要加入\n \r等 不然不算一行
                outputStream.write((msg+"\n").getBytes());
                outputStream.flush();
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

```
### 存在的问题 
上面的代码运行起来后，可以在控制台进行基本的简单的客户端和服务端的通讯，但是上面的代码有几个问题

1. 只能接受一个客户端连接
2. 服务端等待客户端连接只能阻塞等待

### 解决只能接受一个客户端连接
> 解决只能接受一个客户端连接

直接上代码
```java
Server

package com.hyf.demo.bio;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketAddress;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class Server {

    public static void main(String[] args) {

        // 存储socket的list 这里涉及到多线程编程 所以可以使用带锁的list 但是这里demo的话 自己使用synchronized代码去写
        // 这里可以使用CopyOnWriteArrayList 但是CopyOnWriteArrayList 迭代删除的时候会有问题
        // 所以可以使用Collections.synchronizedList(new ArrayList<>());
        List<Socket> socketList = new ArrayList<>();

        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 10,
                60L, TimeUnit.SECONDS, new LinkedBlockingDeque<>(5), new ThreadFactory() {
            @Override
            public Thread newThread(Runnable r) {
                Thread thread = new Thread(r);
                return thread;
            }
        }, new ThreadPoolExecutor.DiscardOldestPolicy());
        // 创建连接
        try {
            ServerSocket serverSocket = new ServerSocket();
            SocketAddress socketAddress = new InetSocketAddress("localhost", 9999);
            serverSocket.bind(socketAddress);
            System.out.println("等待客户端连接");


            // 开启一个线程专门处理客户端连接
            new Thread(() -> {
                while (true) {
                    try {
                        Socket socket = serverSocket.accept();
                        socketList.add(socket);
                        System.out.println("新加入一个客户端，端口 " + socket.getPort());
                        TimeUnit.MILLISECONDS.sleep(200);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }).start();

            // 1.这里会等待客户端连接阻塞
            while (true) {
                synchronized (Server.class) {
                    // 遍历socketList
                    Iterator<Socket> iterator = socketList.iterator();
                    while (iterator.hasNext()) {
                        Socket socket = iterator.next();
                        iterator.remove();
                        // 读取socket输入流中的数据

                        // 2. 这里会阻塞等待客户端消息
                        threadPoolExecutor.execute(() -> {
                            try {
                                BufferedReader inputStream = new BufferedReader(new InputStreamReader(socket.getInputStream()));
                                String msg;
                                while (true) {
                                    if (((msg = inputStream.readLine()) != null)) {
                                        System.out.println(Thread.currentThread().getName() + " 端口 " + socket.getPort() + " " + msg);
                                    }
                                }
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                        });

                    }
                }


            }

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

// Client
package com.hyf.demo.bio;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.SocketAddress;

public class Client {

    public static void main(String[] args) {

        // 创建socket
        Socket socket = new Socket();
        SocketAddress socketAddress = new InetSocketAddress("localhost", 9999);
        try {
            socket.connect(socketAddress);
            System.out.println("连接服务端成功");

            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));

            String msg;
            // 这里会等待控制台输入 阻塞
            while ((msg = bufferedReader.readLine()) != null) {
                OutputStream outputStream = socket.getOutputStream();
                // 使用了readline 需要加入\n \r等 不然不算一行
                outputStream.write((msg+"\n").getBytes());
                outputStream.flush();
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

server输出如下

```shell
等待客户端连接
新加入一个客户端，端口 54968
新加入一个客户端，端口 54972
Thread-1 端口 54968 我是客户端1
Thread-2 端口 54972 我是客户端2
```

client输出如下
```shell
连接服务端成功
我是客户端1
```

#### 解决第二个问题
> 服务端只能阻塞等待

这个问题因为我们使用的是BIO，所以只能阻塞等待，靠开多个线程去进行异步处理，但是这样也只能应对连接数比较少的情景，如果连接数一旦上来，那么一直开线程也是一笔很大的开销，所以才有了NIO这样的的非阻塞IO来解决这个问题


### NIO
NIO和 IO的区别 阻塞的 IO 会阻塞在 IO 操作上, NIO 阻塞在事件获取上

NIO解决的问题

1. 工作在非阻塞线程上，线程利用率提高
2. 适合连接数特别多的场景，但是流量较少


### 常用代码介绍 
常用的一个bytebuffer代码简单介绍
```java
@Slf4j
public class ChannelDemo1 {
    public static void main(String[] args) {
        try (RandomAccessFile file = new RandomAccessFile("data.txt", "rw")) {
            FileChannel channel = file.getChannel();
            ByteBuffer buffer = ByteBuffer.allocate(10);
            do {
                // 向 buffer 写入
                int len = channel.read(buffer);
                log.debug("读到字节数：{}", len);
                if (len == -1) {
                    break;
                }
                // 切换 buffer 读模式
                buffer.flip();
                while(buffer.hasRemaining()) {
                    log.debug("{}", (char)buffer.get());
                }
                // 切换 buffer 写模式 
                // 还有一种 compact模式 是把未读的部分压缩到前边 然后切换到写模式
                buffer.clear();
            } while (true);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```
### 阻塞和非阻塞 nio代码例子
阻塞和非阻塞nio基础服务端代码
```java
package com.hyf.demo.nio;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.ArrayList;
import java.util.List;

import static com.hyf.demo.nio.ByteBufferUtil.debugAll;

public class NioSocketChannel {

    public static void main(String[] args) {

        ByteBuffer byteBuffer = ByteBuffer.allocate(64);

        try {
            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();

            // 设置为非阻塞
            serverSocketChannel.configureBlocking(false);

            serverSocketChannel.bind(new InetSocketAddress(9999));

            List<SocketChannel> channelsList = new ArrayList<>();
            while (true) {

                // 如果是阻塞模式 这里会阻塞
                SocketChannel accept = serverSocketChannel.accept();
                if (accept != null) {
                    // 设置为非阻塞
                    accept.configureBlocking(false);
                    channelsList.add(accept);
                }

                for (SocketChannel socketChannel : channelsList) {
                    // 如果是阻塞模式 这里也会阻塞
                    int read = socketChannel.read(byteBuffer);
                    if (read > 0) {
                        byteBuffer.flip();
                        debugAll(byteBuffer);
                        byteBuffer.clear();
                    }
                }
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```
上面的代码的好处是 设置为非阻塞后，我们的客户端连接就不会阻塞，读取也不会阻塞了，但是这样有个问题就是，会消耗大量cpu（cpu空转、利用率太高），所以我们要使用selector模式，使用selector来管理channel，使用一个线程来管理selector
### selecor 的四种事件

```java
/**
     * Operation-set bit for read operations.
     *
     * <p> Suppose that a selection key's interest set contains
     * <tt>OP_READ</tt> at the start of a <a
     * href="Selector.html#selop">selection operation</a>.  If the selector
     * detects that the corresponding channel is ready for reading, has reached
     * end-of-stream, has been remotely shut down for further reading, or has
     * an error pending, then it will add <tt>OP_READ</tt> to the key's
     * ready-operation set and add the key to its selected-key&nbsp;set.  </p>
     */
    public static final int OP_READ = 1 << 0;

    /**
     * Operation-set bit for write operations.
     *
     * <p> Suppose that a selection key's interest set contains
     * <tt>OP_WRITE</tt> at the start of a <a
     * href="Selector.html#selop">selection operation</a>.  If the selector
     * detects that the corresponding channel is ready for writing, has been
     * remotely shut down for further writing, or has an error pending, then it
     * will add <tt>OP_WRITE</tt> to the key's ready set and add the key to its
     * selected-key&nbsp;set.  </p>
     */
    public static final int OP_WRITE = 1 << 2;

    /**
     * Operation-set bit for socket-connect operations.
     *
     * <p> Suppose that a selection key's interest set contains
     * <tt>OP_CONNECT</tt> at the start of a <a
     * href="Selector.html#selop">selection operation</a>.  If the selector
     * detects that the corresponding socket channel is ready to complete its
     * connection sequence, or has an error pending, then it will add
     * <tt>OP_CONNECT</tt> to the key's ready set and add the key to its
     * selected-key&nbsp;set.  </p>
     */
    public static final int OP_CONNECT = 1 << 3;

    /**
     * Operation-set bit for socket-accept operations.
     *
     * <p> Suppose that a selection key's interest set contains
     * <tt>OP_ACCEPT</tt> at the start of a <a
     * href="Selector.html#selop">selection operation</a>.  If the selector
     * detects that the corresponding server-socket channel is ready to accept
     * another connection, or has an error pending, then it will add
     * <tt>OP_ACCEPT</tt> to the key's ready set and add the key to its
     * selected-key&nbsp;set.  </p>
     */
    public static final int OP_ACCEPT = 1 << 4;
```   
### 使用selector 处理nio消息
下面的这个例子是使用selector处理 nio消息的
```java
package com.hyf.demo.nio;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.charset.CharacterCodingException;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.util.Iterator;
import java.util.Set;

import static com.hyf.demo.nio.ByteBufferUtil.debugAll;

public class NioSelectorSocketChannel {

    public static void main(String[] args) {

        try {
            // 建立selector
            Selector selector = Selector.open();

            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();

            serverSocketChannel.configureBlocking(false);
            // 绑定serverSocketChannel
            SelectionKey selectionKey = serverSocketChannel.register(selector, 0, null);

            // 设置感兴趣的事件
            selectionKey.interestOps(SelectionKey.OP_ACCEPT);

            // 设置为非阻塞
            serverSocketChannel.bind(new InetSocketAddress(9999));

            while (true) {

                // 阻塞 监听事件的发生  如果事件处理了 select会阻塞 如果没处理 则不阻塞  如果不想处理，那就取消事件cancel()
                selector.select();

                Set<SelectionKey> selectionKeys = selector.selectedKeys();
                Iterator<SelectionKey> iterator = selectionKeys.iterator();
                while (iterator.hasNext()) {
                    SelectionKey key = iterator.next();

                    if (key.isAcceptable()) {
                        ServerSocketChannel channel = (ServerSocketChannel) key.channel();
                        SocketChannel socketChannel = channel.accept();
                        // selector都是必须工作在 非阻塞模式
                        socketChannel.configureBlocking(false);
                        // 注册 到selector上  因为一个selector可以管理多个chanel
                        SelectionKey scKey = socketChannel.register(selector, 0, ByteBuffer.allocate(16));
                        scKey.interestOps(SelectionKey.OP_READ);

                    } else if (key.isReadable()) {

                        SocketChannel channel = (SocketChannel) key.channel();
                        ByteBuffer byteBuffer = (ByteBuffer) key.attachment();
                        int read = channel.read(byteBuffer);
                        // 客户端正常断开 返回-1
                        if (read == -1) {
                            key.cancel();
                            channel.close();
                        } else {
                            // 处理粘包
                            split(byteBuffer);
                            // 处理扩容
                            if (byteBuffer.position() == byteBuffer.limit()) {
                                ByteBuffer newBytebuffer = ByteBuffer.allocate(2 * byteBuffer.capacity());
                                byteBuffer.flip();
                                newBytebuffer.put(byteBuffer);
                                key.attach(newBytebuffer);
                            }

//                            byteBuffer.flip();
//                            debugRead(byteBuffer);
                        }
                    }
                    // 需要手动删除  不然事件虽然处理了 绑定事件的key还存在
                    iterator.remove();
                }

            }

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static void split(ByteBuffer byteBuffer) {

        byteBuffer.flip();

        for (int i = 0; i < byteBuffer.limit(); i++) {

            if (byteBuffer.get(i) == '\n') {

                int length = i + 1 - byteBuffer.position();

                ByteBuffer target = ByteBuffer.allocate(length);

                for (int j = 0; j < length; j++) {
                    target.put(byteBuffer.get());
                }

                // 将 position 设置为 0，准备开始读取
                target.flip();
                // 或者将字节转换为字符串并一次性输出
                String output = new String(target.array(), target.position(), target.remaining());
                System.out.println(output);
            }
        }

        byteBuffer.compact();
    }
}

```
上面是服务段代码 客户端代码如下
```java
package com.hyf.demo.nio;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.channels.SocketChannel;
import java.nio.charset.Charset;

public class NioSelectorClient {

    public static void main(String[] args) {

        SocketChannel socketChannel = null;
        try {
            socketChannel = SocketChannel.open();
            socketChannel.connect(new InetSocketAddress(9999));

            socketChannel.write(Charset.defaultCharset().encode("huyunfeinihaocongjianihaok\noolopwew\n"));
            System.in.read();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```
### nio编程解决的问题
> 上面的例子简单解决的以下几个问题
1. 粘包黏包问题（TCP编程必须考虑的问题）
2. 客户端异常中断或者正常退出处理
3. bytebuffer 扩容 （上面只是简单的扩容，但是得考虑bytebuffer的扩容和缩容，做成动态的更好，netty就做的比较好）
    
但是如果我们往客户端发送内容，需要注意哪些问题呢
```java
package com.hyf.demo.nio;

import lombok.extern.slf4j.Slf4j;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.*;
import java.nio.charset.Charset;
import java.util.Iterator;

@Slf4j
public class NioWrite {


    public static void main(String[] args) {

        try {
            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();

            SocketAddress socketAddress = new InetSocketAddress(9000);
            serverSocketChannel.bind(socketAddress);

            serverSocketChannel.configureBlocking(false);

            Selector selector = Selector.open();

            SelectionKey selectionKey = serverSocketChannel.register(selector, 0, null);
            selectionKey.interestOps(SelectionKey.OP_ACCEPT);

            while (true) {

                selector.select();

                Iterator<SelectionKey> iterator = selector.selectedKeys().iterator();

                while (iterator.hasNext()) {

                    SelectionKey key = iterator.next();
                    iterator.remove();;
                    if (key.isAcceptable()) {

                        ServerSocketChannel ssc = (ServerSocketChannel) key.channel();

                        SocketChannel socketChannel = ssc.accept();
                        socketChannel.configureBlocking(false);

                        SelectionKey sckey = socketChannel.register(selector, 0, SelectionKey.OP_READ);

                        StringBuffer stringBuffer = new StringBuffer();
                        for (int i = 0; i < 3000000; i++) {
                            stringBuffer.append("a");
                        }

                        ByteBuffer byteBuffer = Charset.defaultCharset().encode(stringBuffer.toString());
                        int write = socketChannel.write(byteBuffer);
                        log.info("实际写入了 {}", write);
                        if (byteBuffer.hasRemaining()) {
                            sckey.interestOps(SelectionKey.OP_WRITE + sckey.interestOps());
                            sckey.attach(byteBuffer);
                        }
                    } else if (key.isWritable()) {
                        log.info("write able...");
                        ByteBuffer byteBuffer = (ByteBuffer) key.attachment();
                        SocketChannel channel = (SocketChannel)key.channel();
                        int write = channel.write(byteBuffer);
                        if(!byteBuffer.hasRemaining()){
                            log.info("cancel wrible");
                            key.interestOps(key.interestOps()-SelectionKey.OP_WRITE);
                            key.attach(null);
                        }
                        log.info("实际写入了 {}", write);
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
```
对应的客户端例子如下
```java
package com.hyf.demo.nio;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.SocketChannel;
import java.util.Iterator;

public class NioReadClient {


    public static void main(String[] args) throws IOException {

        SocketChannel socketChannel = SocketChannel.open();

        SocketAddress socketAddress = new InetSocketAddress(9000);
        socketChannel.connect(socketAddress);

        int count = 0;

        while (true){
            ByteBuffer byteBuffer = ByteBuffer.allocate(1024);

            int read = socketChannel.read(byteBuffer);
            count += read;
            System.out.println(count);
            byteBuffer.clear();
        }

//        Selector selector = Selector.open();
//        socketChannel.configureBlocking(false);
//        socketChannel.register(selector, SelectionKey.OP_CONNECT + SelectionKey.OP_READ);
//        int count = 0;
//        while (true) {
//            selector.select();
//
//            Iterator<SelectionKey> iterator = selector.selectedKeys().iterator();
//
//            while (iterator.hasNext()){
//                SelectionKey sk = iterator.next();
//                iterator.remove();
//
//                if(sk.isConnectable()){
//                    System.out.println("connect...");
//                }
//                else if(sk.isReadable()){
//                    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
//
//                    int read = socketChannel.read(byteBuffer);
//                    count += read;
//                    System.out.println(count);
//                    byteBuffer.clear();
//                }
//            }
//
//        }


    }
}
```
### 多线程优化nio代码
以上我们展示了nio的读取、写入 以及遇到的问题，但是思考一个问题，我们要实现的是一个高性能的服务器，那么如果有大量连接请求进来，在处理read事件的时候要很久，那单线程是不是就无能为力了，所以我们要将上面的代码优化成多线程的方式，就是一个线程负责建立连接、另外一些线程专门负责读写，代码如下
```java
package com.hyf.demo.nio;

import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.channels.*;
import java.nio.charset.Charset;
import java.util.Iterator;
import java.util.concurrent.ConcurrentLinkedDeque;
import java.util.concurrent.TimeUnit;

@Slf4j
public class NioThreadWork {

    public static void main(String[] args) {

        Thread.currentThread().setName("boss");
        try {
            // 创建一个serverSocketChannel
            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
            // 绑定一个端口
            SocketAddress socketAddress = new InetSocketAddress(9999);
            serverSocketChannel.bind(socketAddress);
            // 设置为false
            serverSocketChannel.configureBlocking(false);
            // 打开一个selector
            Selector selector = Selector.open();
            // 注册chanel 到 selector上
            SelectionKey boosKey = serverSocketChannel.register(selector, 0, null);
            // 注册感兴趣的事件
            boosKey.interestOps(SelectionKey.OP_ACCEPT);

            Worker worker = new Worker("work");
            while (true) {

                log.info("等待连接中");
                selector.select();

                Iterator<SelectionKey> iterator = selector.selectedKeys().iterator();
                while (iterator.hasNext()) {

                    SelectionKey key = iterator.next();
                    iterator.remove();
                    if (key.isAcceptable()) {
                        log.info("连接事件建立");

                        ServerSocketChannel ssc = (ServerSocketChannel) key.channel();
                        SocketChannel socketChannel = ssc.accept();
                        socketChannel.configureBlocking(false);

                        log.info("注册读取事件 before");
                        worker.register(socketChannel);
                        log.info("注册读取事件 after");

                    }


                }

            }


        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    public static class Worker implements Runnable {

        private String name;
        private Thread thread;
        private volatile Selector selector;
        private volatile boolean start = false;
        private ConcurrentLinkedDeque<Runnable> linkedDeque = new ConcurrentLinkedDeque<>();

        public Worker(String name) {
            this.name = name;
        }

        public void register(SocketChannel socketChannel) throws IOException {

            if (!start) {
                thread = new Thread(this, name);
                thread.start();
                selector = Selector.open();
                start = true;
            }

            linkedDeque.offer(() -> {
                try {
                    socketChannel.register(selector, SelectionKey.OP_READ);
                } catch (ClosedChannelException e) {
                    e.printStackTrace();
                }
            });

            selector.wakeup();
        }

        @SneakyThrows
        @Override
        public void run() {
            while (true) {

                Runnable poll = linkedDeque.poll();
                if (poll != null) {
                    poll.run();
                }
                log.info("读取事件阻塞");
                selector.select();

                Iterator<SelectionKey> iterator = selector.selectedKeys().iterator();
                while (iterator.hasNext()) {
                    SelectionKey key = iterator.next();
                    iterator.remove();

                    if (key.isReadable()) {
                        log.info("读数据开始");
                        SocketChannel channel = (SocketChannel) key.channel();
                        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);

                        channel.read(byteBuffer);
                        byteBuffer.flip();

                        CharBuffer decode = Charset.defaultCharset().decode(byteBuffer);
                        while (decode.hasRemaining()) {
                            log.info("content {}", decode.get());
                        }
                    }

                }
            }


        }
    }
}
```

客户端代码如下
```java
package com.hyf.demo.nio;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.nio.channels.SocketChannel;
import java.nio.charset.Charset;

public class NioThreadClient {

    public static void main(String[] args) {


        try {
            SocketChannel socketChannel =SocketChannel.open();

            SocketAddress socketAddress = new InetSocketAddress(9999);
            socketChannel.connect(socketAddress);

            socketChannel.write(Charset.defaultCharset().encode("你好"));

            System.in.read();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
```
以上代码便实现了一个简易的多线程版本的读写服务端和客户端，如果再完善的话，可以加上我们之前的各种优化点，对bytebuffer的扩容、对粘包的处理，对客户端异常关闭正常关闭的处理等 会让代码更加完善，但是我们自己处理还是会有很多问题，比如nio有很多代码其实是一样的，而且还有一个臭名昭著的空轮训导致cpu打满的问题，所以有必要封装一套高性能的网络框架来处理这些问题，也就是大名鼎鼎的netty

所以下一篇,我就来简单介绍下netty的使用以及原理
