---
title: NIO
thumbnail:  /img/nio-RoundCorner.png
cover: /img/nio.jpg
categories: 
- java
- ç½‘ç»œç¼–ç¨‹
tags: ç½‘ç»œç¼–ç¨‹
toc: true
---
ä¸Šä¸€ç¯‡è¯´è¿‡äº†åŸºç¡€IOæµçš„æ“ä½œï¼Œè¿™ç¯‡ç®€å•è¯´ä¸€ä¸‹ç½‘ç»œç¼–ç¨‹ï¼Œç½‘ç»œç¼–ç¨‹å°±æˆ‘è‡ªå·±ç†è§£å°±æ˜¯åœ¨ç½‘ç»œä¸–ç•Œä¸­è¿›è¡Œæ•°æ®çš„äº’ç›¸ä¼ é€’ï¼Œå®ƒåŸºäºOSIä¸ƒå±‚æ¨¡å‹ï¼Œè¿›è¡Œå±‚å±‚å°è£…ï¼Œæ¥å°†æ•°æ®æœ€ç»ˆå°è£…æˆäº†ä¸€ä¸ªä¸ªæ•°æ®åŒ…ï¼Œç„¶åå‘å¾€å¦å¤–ä¸€ç«¯ï¼Œè¿™ç¯‡æš‚æ—¶ä¸è¯´TCPã€UDPä»¥åŠsocketé€šä¿¡çš„å…¶å®ƒåè®®ï¼Œè¿™ç¯‡åªè¯´ä¸€ä¸‹è·ŸIOç›¸å…³çš„ç½‘ç»œç¼–ç¨‹
<!--more-->
### ç›´æ¥ä¸Šæ —å­
#### æœ€ç®€å•çš„IO
ä¸€ä¸ªç®€å•çš„åŸºäºIOçš„ç½‘ç»œç¼–ç¨‹ğŸŒ°
```java
// Server
package com.hyf.demo.bio;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketAddress;

public class Server {

    public static void main(String[] args) {


        // åˆ›å»ºè¿æ¥
        try {
            ServerSocket serverSocket = new ServerSocket();
            SocketAddress socketAddress = new InetSocketAddress("localhost", 9999);
            serverSocket.bind(socketAddress);
            System.out.println("ç­‰å¾…å®¢æˆ·ç«¯è¿æ¥");
            // 1.è¿™é‡Œä¼šç­‰å¾…å®¢æˆ·ç«¯è¿æ¥é˜»å¡
            Socket socket = serverSocket.accept();
            System.out.println("å®¢æˆ·ç«¯è¿æ¥æˆåŠŸ");

            // è¯»å–socketè¾“å…¥æµä¸­çš„æ•°æ®
            BufferedReader inputStream = new BufferedReader(new InputStreamReader(socket.getInputStream()));

            String msg;
            // 2. è¿™é‡Œä¼šé˜»å¡ç­‰å¾…å®¢æˆ·ç«¯æ¶ˆæ¯
            while ((msg = inputStream.readLine()) != null) {
                System.out.println(msg);
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

// Client
package com.hyf.demo.bio;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.SocketAddress;

public class Client {

    public static void main(String[] args) {

        // åˆ›å»ºsocket
        Socket socket = new Socket();
        SocketAddress socketAddress = new InetSocketAddress("localhost", 9999);
        try {
            socket.connect(socketAddress);
            System.out.println("è¿æ¥æœåŠ¡ç«¯æˆåŠŸ");

            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));

            String msg;
            // è¿™é‡Œä¼šç­‰å¾…æ§åˆ¶å°è¾“å…¥ é˜»å¡
            while ((msg = bufferedReader.readLine()) != null) {
                OutputStream outputStream = socket.getOutputStream();
                // ä½¿ç”¨äº†readline éœ€è¦åŠ å…¥\n \rç­‰ ä¸ç„¶ä¸ç®—ä¸€è¡Œ
                outputStream.write((msg+"\n").getBytes());
                outputStream.flush();
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

```
### å­˜åœ¨çš„é—®é¢˜ 
ä¸Šé¢çš„ä»£ç è¿è¡Œèµ·æ¥åï¼Œå¯ä»¥åœ¨æ§åˆ¶å°è¿›è¡ŒåŸºæœ¬çš„ç®€å•çš„å®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯çš„é€šè®¯ï¼Œä½†æ˜¯ä¸Šé¢çš„ä»£ç æœ‰å‡ ä¸ªé—®é¢˜

1. åªèƒ½æ¥å—ä¸€ä¸ªå®¢æˆ·ç«¯è¿æ¥
2. æœåŠ¡ç«¯ç­‰å¾…å®¢æˆ·ç«¯è¿æ¥åªèƒ½é˜»å¡ç­‰å¾…

### è§£å†³åªèƒ½æ¥å—ä¸€ä¸ªå®¢æˆ·ç«¯è¿æ¥
> è§£å†³åªèƒ½æ¥å—ä¸€ä¸ªå®¢æˆ·ç«¯è¿æ¥

ç›´æ¥ä¸Šä»£ç 
```java
Server

package com.hyf.demo.bio;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketAddress;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class Server {

    public static void main(String[] args) {

        // å­˜å‚¨socketçš„list è¿™é‡Œæ¶‰åŠåˆ°å¤šçº¿ç¨‹ç¼–ç¨‹ æ‰€ä»¥å¯ä»¥ä½¿ç”¨å¸¦é”çš„list ä½†æ˜¯è¿™é‡Œdemoçš„è¯ è‡ªå·±ä½¿ç”¨synchronizedä»£ç å»å†™
        // è¿™é‡Œå¯ä»¥ä½¿ç”¨CopyOnWriteArrayList ä½†æ˜¯CopyOnWriteArrayList è¿­ä»£åˆ é™¤çš„æ—¶å€™ä¼šæœ‰é—®é¢˜
        // æ‰€ä»¥å¯ä»¥ä½¿ç”¨Collections.synchronizedList(new ArrayList<>());
        List<Socket> socketList = new ArrayList<>();

        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 10,
                60L, TimeUnit.SECONDS, new LinkedBlockingDeque<>(5), new ThreadFactory() {
            @Override
            public Thread newThread(Runnable r) {
                Thread thread = new Thread(r);
                return thread;
            }
        }, new ThreadPoolExecutor.DiscardOldestPolicy());
        // åˆ›å»ºè¿æ¥
        try {
            ServerSocket serverSocket = new ServerSocket();
            SocketAddress socketAddress = new InetSocketAddress("localhost", 9999);
            serverSocket.bind(socketAddress);
            System.out.println("ç­‰å¾…å®¢æˆ·ç«¯è¿æ¥");


            // å¼€å¯ä¸€ä¸ªçº¿ç¨‹ä¸“é—¨å¤„ç†å®¢æˆ·ç«¯è¿æ¥
            new Thread(() -> {
                while (true) {
                    try {
                        Socket socket = serverSocket.accept();
                        socketList.add(socket);
                        System.out.println("æ–°åŠ å…¥ä¸€ä¸ªå®¢æˆ·ç«¯ï¼Œç«¯å£ " + socket.getPort());
                        TimeUnit.MILLISECONDS.sleep(200);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }).start();

            // 1.è¿™é‡Œä¼šç­‰å¾…å®¢æˆ·ç«¯è¿æ¥é˜»å¡
            while (true) {
                synchronized (Server.class) {
                    // éå†socketList
                    Iterator<Socket> iterator = socketList.iterator();
                    while (iterator.hasNext()) {
                        Socket socket = iterator.next();
                        iterator.remove();
                        // è¯»å–socketè¾“å…¥æµä¸­çš„æ•°æ®

                        // 2. è¿™é‡Œä¼šé˜»å¡ç­‰å¾…å®¢æˆ·ç«¯æ¶ˆæ¯
                        threadPoolExecutor.execute(() -> {
                            try {
                                BufferedReader inputStream = new BufferedReader(new InputStreamReader(socket.getInputStream()));
                                String msg;
                                while (true) {
                                    if (((msg = inputStream.readLine()) != null)) {
                                        System.out.println(Thread.currentThread().getName() + " ç«¯å£ " + socket.getPort() + " " + msg);
                                    }
                                }
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                        });

                    }
                }


            }

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

// Client
package com.hyf.demo.bio;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.SocketAddress;

public class Client {

    public static void main(String[] args) {

        // åˆ›å»ºsocket
        Socket socket = new Socket();
        SocketAddress socketAddress = new InetSocketAddress("localhost", 9999);
        try {
            socket.connect(socketAddress);
            System.out.println("è¿æ¥æœåŠ¡ç«¯æˆåŠŸ");

            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));

            String msg;
            // è¿™é‡Œä¼šç­‰å¾…æ§åˆ¶å°è¾“å…¥ é˜»å¡
            while ((msg = bufferedReader.readLine()) != null) {
                OutputStream outputStream = socket.getOutputStream();
                // ä½¿ç”¨äº†readline éœ€è¦åŠ å…¥\n \rç­‰ ä¸ç„¶ä¸ç®—ä¸€è¡Œ
                outputStream.write((msg+"\n").getBytes());
                outputStream.flush();
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

serverè¾“å‡ºå¦‚ä¸‹

```shell
ç­‰å¾…å®¢æˆ·ç«¯è¿æ¥
æ–°åŠ å…¥ä¸€ä¸ªå®¢æˆ·ç«¯ï¼Œç«¯å£ 54968
æ–°åŠ å…¥ä¸€ä¸ªå®¢æˆ·ç«¯ï¼Œç«¯å£ 54972
Thread-1 ç«¯å£ 54968 æˆ‘æ˜¯å®¢æˆ·ç«¯1
Thread-2 ç«¯å£ 54972 æˆ‘æ˜¯å®¢æˆ·ç«¯2
```

clientè¾“å‡ºå¦‚ä¸‹
```shell
è¿æ¥æœåŠ¡ç«¯æˆåŠŸ
æˆ‘æ˜¯å®¢æˆ·ç«¯1
```

#### è§£å†³ç¬¬äºŒä¸ªé—®é¢˜
> æœåŠ¡ç«¯åªèƒ½é˜»å¡ç­‰å¾…

è¿™ä¸ªé—®é¢˜å› ä¸ºæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯BIOï¼Œæ‰€ä»¥åªèƒ½é˜»å¡ç­‰å¾…ï¼Œé å¼€å¤šä¸ªçº¿ç¨‹å»è¿›è¡Œå¼‚æ­¥å¤„ç†ï¼Œä½†æ˜¯è¿™æ ·ä¹Ÿåªèƒ½åº”å¯¹è¿æ¥æ•°æ¯”è¾ƒå°‘çš„æƒ…æ™¯ï¼Œå¦‚æœè¿æ¥æ•°ä¸€æ—¦ä¸Šæ¥ï¼Œé‚£ä¹ˆä¸€ç›´å¼€çº¿ç¨‹ä¹Ÿæ˜¯ä¸€ç¬”å¾ˆå¤§çš„å¼€é”€ï¼Œæ‰€ä»¥æ‰æœ‰äº†NIOè¿™æ ·çš„çš„éé˜»å¡IOæ¥è§£å†³è¿™ä¸ªé—®é¢˜


### NIO
NIOå’Œ IOçš„åŒºåˆ« é˜»å¡çš„ IO ä¼šé˜»å¡åœ¨ IO æ“ä½œä¸Š, NIO é˜»å¡åœ¨äº‹ä»¶è·å–ä¸Š

NIOè§£å†³çš„é—®é¢˜

1. å·¥ä½œåœ¨éé˜»å¡çº¿ç¨‹ä¸Šï¼Œçº¿ç¨‹åˆ©ç”¨ç‡æé«˜
2. é€‚åˆè¿æ¥æ•°ç‰¹åˆ«å¤šçš„åœºæ™¯ï¼Œä½†æ˜¯æµé‡è¾ƒå°‘


### å¸¸ç”¨ä»£ç ä»‹ç» 
å¸¸ç”¨çš„ä¸€ä¸ªbytebufferä»£ç ç®€å•ä»‹ç»
```java
@Slf4j
public class ChannelDemo1 {
    public static void main(String[] args) {
        try (RandomAccessFile file = new RandomAccessFile("data.txt", "rw")) {
            FileChannel channel = file.getChannel();
            ByteBuffer buffer = ByteBuffer.allocate(10);
            do {
                // å‘ buffer å†™å…¥
                int len = channel.read(buffer);
                log.debug("è¯»åˆ°å­—èŠ‚æ•°ï¼š{}", len);
                if (len == -1) {
                    break;
                }
                // åˆ‡æ¢ buffer è¯»æ¨¡å¼
                buffer.flip();
                while(buffer.hasRemaining()) {
                    log.debug("{}", (char)buffer.get());
                }
                // åˆ‡æ¢ buffer å†™æ¨¡å¼ 
                // è¿˜æœ‰ä¸€ç§ compactæ¨¡å¼ æ˜¯æŠŠæœªè¯»çš„éƒ¨åˆ†å‹ç¼©åˆ°å‰è¾¹ ç„¶ååˆ‡æ¢åˆ°å†™æ¨¡å¼
                buffer.clear();
            } while (true);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```
### é˜»å¡å’Œéé˜»å¡ nioä»£ç ä¾‹å­
é˜»å¡å’Œéé˜»å¡nioåŸºç¡€æœåŠ¡ç«¯ä»£ç 
```java
package com.hyf.demo.nio;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.ArrayList;
import java.util.List;

import static com.hyf.demo.nio.ByteBufferUtil.debugAll;

public class NioSocketChannel {

    public static void main(String[] args) {

        ByteBuffer byteBuffer = ByteBuffer.allocate(64);

        try {
            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();

            // è®¾ç½®ä¸ºéé˜»å¡
            serverSocketChannel.configureBlocking(false);

            serverSocketChannel.bind(new InetSocketAddress(9999));

            List<SocketChannel> channelsList = new ArrayList<>();
            while (true) {

                // å¦‚æœæ˜¯é˜»å¡æ¨¡å¼ è¿™é‡Œä¼šé˜»å¡
                SocketChannel accept = serverSocketChannel.accept();
                if (accept != null) {
                    // è®¾ç½®ä¸ºéé˜»å¡
                    accept.configureBlocking(false);
                    channelsList.add(accept);
                }

                for (SocketChannel socketChannel : channelsList) {
                    // å¦‚æœæ˜¯é˜»å¡æ¨¡å¼ è¿™é‡Œä¹Ÿä¼šé˜»å¡
                    int read = socketChannel.read(byteBuffer);
                    if (read > 0) {
                        byteBuffer.flip();
                        debugAll(byteBuffer);
                        byteBuffer.clear();
                    }
                }
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```
ä¸Šé¢çš„ä»£ç çš„å¥½å¤„æ˜¯ è®¾ç½®ä¸ºéé˜»å¡åï¼Œæˆ‘ä»¬çš„å®¢æˆ·ç«¯è¿æ¥å°±ä¸ä¼šé˜»å¡ï¼Œè¯»å–ä¹Ÿä¸ä¼šé˜»å¡äº†ï¼Œä½†æ˜¯è¿™æ ·æœ‰ä¸ªé—®é¢˜å°±æ˜¯ï¼Œä¼šæ¶ˆè€—å¤§é‡cpuï¼ˆcpuç©ºè½¬ã€åˆ©ç”¨ç‡å¤ªé«˜ï¼‰ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦ä½¿ç”¨selectoræ¨¡å¼ï¼Œä½¿ç”¨selectoræ¥ç®¡ç†channelï¼Œä½¿ç”¨ä¸€ä¸ªçº¿ç¨‹æ¥ç®¡ç†selector
### selecor çš„å››ç§äº‹ä»¶

```java
/**
     * Operation-set bit for read operations.
     *
     * <p> Suppose that a selection key's interest set contains
     * <tt>OP_READ</tt> at the start of a <a
     * href="Selector.html#selop">selection operation</a>.  If the selector
     * detects that the corresponding channel is ready for reading, has reached
     * end-of-stream, has been remotely shut down for further reading, or has
     * an error pending, then it will add <tt>OP_READ</tt> to the key's
     * ready-operation set and add the key to its selected-key&nbsp;set.  </p>
     */
    public static final int OP_READ = 1 << 0;

    /**
     * Operation-set bit for write operations.
     *
     * <p> Suppose that a selection key's interest set contains
     * <tt>OP_WRITE</tt> at the start of a <a
     * href="Selector.html#selop">selection operation</a>.  If the selector
     * detects that the corresponding channel is ready for writing, has been
     * remotely shut down for further writing, or has an error pending, then it
     * will add <tt>OP_WRITE</tt> to the key's ready set and add the key to its
     * selected-key&nbsp;set.  </p>
     */
    public static final int OP_WRITE = 1 << 2;

    /**
     * Operation-set bit for socket-connect operations.
     *
     * <p> Suppose that a selection key's interest set contains
     * <tt>OP_CONNECT</tt> at the start of a <a
     * href="Selector.html#selop">selection operation</a>.  If the selector
     * detects that the corresponding socket channel is ready to complete its
     * connection sequence, or has an error pending, then it will add
     * <tt>OP_CONNECT</tt> to the key's ready set and add the key to its
     * selected-key&nbsp;set.  </p>
     */
    public static final int OP_CONNECT = 1 << 3;

    /**
     * Operation-set bit for socket-accept operations.
     *
     * <p> Suppose that a selection key's interest set contains
     * <tt>OP_ACCEPT</tt> at the start of a <a
     * href="Selector.html#selop">selection operation</a>.  If the selector
     * detects that the corresponding server-socket channel is ready to accept
     * another connection, or has an error pending, then it will add
     * <tt>OP_ACCEPT</tt> to the key's ready set and add the key to its
     * selected-key&nbsp;set.  </p>
     */
    public static final int OP_ACCEPT = 1 << 4;
```   
### ä½¿ç”¨selector å¤„ç†nioæ¶ˆæ¯
ä¸‹é¢çš„è¿™ä¸ªä¾‹å­æ˜¯ä½¿ç”¨selectorå¤„ç† nioæ¶ˆæ¯çš„
```java
package com.hyf.demo.nio;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.charset.CharacterCodingException;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.util.Iterator;
import java.util.Set;

import static com.hyf.demo.nio.ByteBufferUtil.debugAll;

public class NioSelectorSocketChannel {

    public static void main(String[] args) {

        try {
            // å»ºç«‹selector
            Selector selector = Selector.open();

            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();

            serverSocketChannel.configureBlocking(false);
            // ç»‘å®šserverSocketChannel
            SelectionKey selectionKey = serverSocketChannel.register(selector, 0, null);

            // è®¾ç½®æ„Ÿå…´è¶£çš„äº‹ä»¶
            selectionKey.interestOps(SelectionKey.OP_ACCEPT);

            // è®¾ç½®ä¸ºéé˜»å¡
            serverSocketChannel.bind(new InetSocketAddress(9999));

            while (true) {

                // é˜»å¡ ç›‘å¬äº‹ä»¶çš„å‘ç”Ÿ  å¦‚æœäº‹ä»¶å¤„ç†äº† selectä¼šé˜»å¡ å¦‚æœæ²¡å¤„ç† åˆ™ä¸é˜»å¡  å¦‚æœä¸æƒ³å¤„ç†ï¼Œé‚£å°±å–æ¶ˆäº‹ä»¶cancel()
                selector.select();

                Set<SelectionKey> selectionKeys = selector.selectedKeys();
                Iterator<SelectionKey> iterator = selectionKeys.iterator();
                while (iterator.hasNext()) {
                    SelectionKey key = iterator.next();

                    if (key.isAcceptable()) {
                        ServerSocketChannel channel = (ServerSocketChannel) key.channel();
                        SocketChannel socketChannel = channel.accept();
                        // selectoréƒ½æ˜¯å¿…é¡»å·¥ä½œåœ¨ éé˜»å¡æ¨¡å¼
                        socketChannel.configureBlocking(false);
                        // æ³¨å†Œ åˆ°selectorä¸Š  å› ä¸ºä¸€ä¸ªselectorå¯ä»¥ç®¡ç†å¤šä¸ªchanel
                        SelectionKey scKey = socketChannel.register(selector, 0, ByteBuffer.allocate(16));
                        scKey.interestOps(SelectionKey.OP_READ);

                    } else if (key.isReadable()) {

                        SocketChannel channel = (SocketChannel) key.channel();
                        ByteBuffer byteBuffer = (ByteBuffer) key.attachment();
                        int read = channel.read(byteBuffer);
                        // å®¢æˆ·ç«¯æ­£å¸¸æ–­å¼€ è¿”å›-1
                        if (read == -1) {
                            key.cancel();
                            channel.close();
                        } else {
                            // å¤„ç†ç²˜åŒ…
                            split(byteBuffer);
                            // å¤„ç†æ‰©å®¹
                            if (byteBuffer.position() == byteBuffer.limit()) {
                                ByteBuffer newBytebuffer = ByteBuffer.allocate(2 * byteBuffer.capacity());
                                byteBuffer.flip();
                                newBytebuffer.put(byteBuffer);
                                key.attach(newBytebuffer);
                            }

//                            byteBuffer.flip();
//                            debugRead(byteBuffer);
                        }
                    }
                    // éœ€è¦æ‰‹åŠ¨åˆ é™¤  ä¸ç„¶äº‹ä»¶è™½ç„¶å¤„ç†äº† ç»‘å®šäº‹ä»¶çš„keyè¿˜å­˜åœ¨
                    iterator.remove();
                }

            }

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static void split(ByteBuffer byteBuffer) {

        byteBuffer.flip();

        for (int i = 0; i < byteBuffer.limit(); i++) {

            if (byteBuffer.get(i) == '\n') {

                int length = i + 1 - byteBuffer.position();

                ByteBuffer target = ByteBuffer.allocate(length);

                for (int j = 0; j < length; j++) {
                    target.put(byteBuffer.get());
                }

                // å°† position è®¾ç½®ä¸º 0ï¼Œå‡†å¤‡å¼€å§‹è¯»å–
                target.flip();
                // æˆ–è€…å°†å­—èŠ‚è½¬æ¢ä¸ºå­—ç¬¦ä¸²å¹¶ä¸€æ¬¡æ€§è¾“å‡º
                String output = new String(target.array(), target.position(), target.remaining());
                System.out.println(output);
            }
        }

        byteBuffer.compact();
    }
}

```
ä¸Šé¢æ˜¯æœåŠ¡æ®µä»£ç  å®¢æˆ·ç«¯ä»£ç å¦‚ä¸‹
```java
package com.hyf.demo.nio;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.channels.SocketChannel;
import java.nio.charset.Charset;

public class NioSelectorClient {

    public static void main(String[] args) {

        SocketChannel socketChannel = null;
        try {
            socketChannel = SocketChannel.open();
            socketChannel.connect(new InetSocketAddress(9999));

            socketChannel.write(Charset.defaultCharset().encode("huyunfeinihaocongjianihaok\noolopwew\n"));
            System.in.read();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```
### nioç¼–ç¨‹è§£å†³çš„é—®é¢˜
> ä¸Šé¢çš„ä¾‹å­ç®€å•è§£å†³çš„ä»¥ä¸‹å‡ ä¸ªé—®é¢˜
1. ç²˜åŒ…é»åŒ…é—®é¢˜ï¼ˆTCPç¼–ç¨‹å¿…é¡»è€ƒè™‘çš„é—®é¢˜ï¼‰
2. å®¢æˆ·ç«¯å¼‚å¸¸ä¸­æ–­æˆ–è€…æ­£å¸¸é€€å‡ºå¤„ç†
3. bytebuffer æ‰©å®¹ ï¼ˆä¸Šé¢åªæ˜¯ç®€å•çš„æ‰©å®¹ï¼Œä½†æ˜¯å¾—è€ƒè™‘bytebufferçš„æ‰©å®¹å’Œç¼©å®¹ï¼ŒåšæˆåŠ¨æ€çš„æ›´å¥½ï¼Œnettyå°±åšçš„æ¯”è¾ƒå¥½ï¼‰
    
ä½†æ˜¯å¦‚æœæˆ‘ä»¬å¾€å®¢æˆ·ç«¯å‘é€å†…å®¹ï¼Œéœ€è¦æ³¨æ„å“ªäº›é—®é¢˜å‘¢
```java
package com.hyf.demo.nio;

import lombok.extern.slf4j.Slf4j;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.*;
import java.nio.charset.Charset;
import java.util.Iterator;

@Slf4j
public class NioWrite {


    public static void main(String[] args) {

        try {
            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();

            SocketAddress socketAddress = new InetSocketAddress(9000);
            serverSocketChannel.bind(socketAddress);

            serverSocketChannel.configureBlocking(false);

            Selector selector = Selector.open();

            SelectionKey selectionKey = serverSocketChannel.register(selector, 0, null);
            selectionKey.interestOps(SelectionKey.OP_ACCEPT);

            while (true) {

                selector.select();

                Iterator<SelectionKey> iterator = selector.selectedKeys().iterator();

                while (iterator.hasNext()) {

                    SelectionKey key = iterator.next();
                    iterator.remove();;
                    if (key.isAcceptable()) {

                        ServerSocketChannel ssc = (ServerSocketChannel) key.channel();

                        SocketChannel socketChannel = ssc.accept();
                        socketChannel.configureBlocking(false);

                        SelectionKey sckey = socketChannel.register(selector, 0, SelectionKey.OP_READ);

                        StringBuffer stringBuffer = new StringBuffer();
                        for (int i = 0; i < 3000000; i++) {
                            stringBuffer.append("a");
                        }

                        ByteBuffer byteBuffer = Charset.defaultCharset().encode(stringBuffer.toString());
                        int write = socketChannel.write(byteBuffer);
                        log.info("å®é™…å†™å…¥äº† {}", write);
                        if (byteBuffer.hasRemaining()) {
                            sckey.interestOps(SelectionKey.OP_WRITE + sckey.interestOps());
                            sckey.attach(byteBuffer);
                        }
                    } else if (key.isWritable()) {
                        log.info("write able...");
                        ByteBuffer byteBuffer = (ByteBuffer) key.attachment();
                        SocketChannel channel = (SocketChannel)key.channel();
                        int write = channel.write(byteBuffer);
                        if(!byteBuffer.hasRemaining()){
                            log.info("cancel wrible");
                            key.interestOps(key.interestOps()-SelectionKey.OP_WRITE);
                            key.attach(null);
                        }
                        log.info("å®é™…å†™å…¥äº† {}", write);
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
```
å¯¹åº”çš„å®¢æˆ·ç«¯ä¾‹å­å¦‚ä¸‹
```java
package com.hyf.demo.nio;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.SocketChannel;
import java.util.Iterator;

public class NioReadClient {


    public static void main(String[] args) throws IOException {

        SocketChannel socketChannel = SocketChannel.open();

        SocketAddress socketAddress = new InetSocketAddress(9000);
        socketChannel.connect(socketAddress);

        int count = 0;

        while (true){
            ByteBuffer byteBuffer = ByteBuffer.allocate(1024);

            int read = socketChannel.read(byteBuffer);
            count += read;
            System.out.println(count);
            byteBuffer.clear();
        }

//        Selector selector = Selector.open();
//        socketChannel.configureBlocking(false);
//        socketChannel.register(selector, SelectionKey.OP_CONNECT + SelectionKey.OP_READ);
//        int count = 0;
//        while (true) {
//            selector.select();
//
//            Iterator<SelectionKey> iterator = selector.selectedKeys().iterator();
//
//            while (iterator.hasNext()){
//                SelectionKey sk = iterator.next();
//                iterator.remove();
//
//                if(sk.isConnectable()){
//                    System.out.println("connect...");
//                }
//                else if(sk.isReadable()){
//                    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
//
//                    int read = socketChannel.read(byteBuffer);
//                    count += read;
//                    System.out.println(count);
//                    byteBuffer.clear();
//                }
//            }
//
//        }


    }
}
```
### å¤šçº¿ç¨‹ä¼˜åŒ–nioä»£ç 
ä»¥ä¸Šæˆ‘ä»¬å±•ç¤ºäº†nioçš„è¯»å–ã€å†™å…¥ ä»¥åŠé‡åˆ°çš„é—®é¢˜ï¼Œä½†æ˜¯æ€è€ƒä¸€ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬è¦å®ç°çš„æ˜¯ä¸€ä¸ªé«˜æ€§èƒ½çš„æœåŠ¡å™¨ï¼Œé‚£ä¹ˆå¦‚æœæœ‰å¤§é‡è¿æ¥è¯·æ±‚è¿›æ¥ï¼Œåœ¨å¤„ç†readäº‹ä»¶çš„æ—¶å€™è¦å¾ˆä¹…ï¼Œé‚£å•çº¿ç¨‹æ˜¯ä¸æ˜¯å°±æ— èƒ½ä¸ºåŠ›äº†ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦å°†ä¸Šé¢çš„ä»£ç ä¼˜åŒ–æˆå¤šçº¿ç¨‹çš„æ–¹å¼ï¼Œå°±æ˜¯ä¸€ä¸ªçº¿ç¨‹è´Ÿè´£å»ºç«‹è¿æ¥ã€å¦å¤–ä¸€äº›çº¿ç¨‹ä¸“é—¨è´Ÿè´£è¯»å†™ï¼Œä»£ç å¦‚ä¸‹
```java
package com.hyf.demo.nio;

import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.channels.*;
import java.nio.charset.Charset;
import java.util.Iterator;
import java.util.concurrent.ConcurrentLinkedDeque;
import java.util.concurrent.TimeUnit;

@Slf4j
public class NioThreadWork {

    public static void main(String[] args) {

        Thread.currentThread().setName("boss");
        try {
            // åˆ›å»ºä¸€ä¸ªserverSocketChannel
            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
            // ç»‘å®šä¸€ä¸ªç«¯å£
            SocketAddress socketAddress = new InetSocketAddress(9999);
            serverSocketChannel.bind(socketAddress);
            // è®¾ç½®ä¸ºfalse
            serverSocketChannel.configureBlocking(false);
            // æ‰“å¼€ä¸€ä¸ªselector
            Selector selector = Selector.open();
            // æ³¨å†Œchanel åˆ° selectorä¸Š
            SelectionKey boosKey = serverSocketChannel.register(selector, 0, null);
            // æ³¨å†Œæ„Ÿå…´è¶£çš„äº‹ä»¶
            boosKey.interestOps(SelectionKey.OP_ACCEPT);

            Worker worker = new Worker("work");
            while (true) {

                log.info("ç­‰å¾…è¿æ¥ä¸­");
                selector.select();

                Iterator<SelectionKey> iterator = selector.selectedKeys().iterator();
                while (iterator.hasNext()) {

                    SelectionKey key = iterator.next();
                    iterator.remove();
                    if (key.isAcceptable()) {
                        log.info("è¿æ¥äº‹ä»¶å»ºç«‹");

                        ServerSocketChannel ssc = (ServerSocketChannel) key.channel();
                        SocketChannel socketChannel = ssc.accept();
                        socketChannel.configureBlocking(false);

                        log.info("æ³¨å†Œè¯»å–äº‹ä»¶ before");
                        worker.register(socketChannel);
                        log.info("æ³¨å†Œè¯»å–äº‹ä»¶ after");

                    }


                }

            }


        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    public static class Worker implements Runnable {

        private String name;
        private Thread thread;
        private volatile Selector selector;
        private volatile boolean start = false;
        private ConcurrentLinkedDeque<Runnable> linkedDeque = new ConcurrentLinkedDeque<>();

        public Worker(String name) {
            this.name = name;
        }

        public void register(SocketChannel socketChannel) throws IOException {

            if (!start) {
                thread = new Thread(this, name);
                thread.start();
                selector = Selector.open();
                start = true;
            }

            linkedDeque.offer(() -> {
                try {
                    socketChannel.register(selector, SelectionKey.OP_READ);
                } catch (ClosedChannelException e) {
                    e.printStackTrace();
                }
            });

            selector.wakeup();
        }

        @SneakyThrows
        @Override
        public void run() {
            while (true) {

                Runnable poll = linkedDeque.poll();
                if (poll != null) {
                    poll.run();
                }
                log.info("è¯»å–äº‹ä»¶é˜»å¡");
                selector.select();

                Iterator<SelectionKey> iterator = selector.selectedKeys().iterator();
                while (iterator.hasNext()) {
                    SelectionKey key = iterator.next();
                    iterator.remove();

                    if (key.isReadable()) {
                        log.info("è¯»æ•°æ®å¼€å§‹");
                        SocketChannel channel = (SocketChannel) key.channel();
                        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);

                        channel.read(byteBuffer);
                        byteBuffer.flip();

                        CharBuffer decode = Charset.defaultCharset().decode(byteBuffer);
                        while (decode.hasRemaining()) {
                            log.info("content {}", decode.get());
                        }
                    }

                }
            }


        }
    }
}
```

å®¢æˆ·ç«¯ä»£ç å¦‚ä¸‹
```java
package com.hyf.demo.nio;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.nio.channels.SocketChannel;
import java.nio.charset.Charset;

public class NioThreadClient {

    public static void main(String[] args) {


        try {
            SocketChannel socketChannel =SocketChannel.open();

            SocketAddress socketAddress = new InetSocketAddress(9999);
            socketChannel.connect(socketAddress);

            socketChannel.write(Charset.defaultCharset().encode("ä½ å¥½"));

            System.in.read();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
```
ä»¥ä¸Šä»£ç ä¾¿å®ç°äº†ä¸€ä¸ªç®€æ˜“çš„å¤šçº¿ç¨‹ç‰ˆæœ¬çš„è¯»å†™æœåŠ¡ç«¯å’Œå®¢æˆ·ç«¯ï¼Œå¦‚æœå†å®Œå–„çš„è¯ï¼Œå¯ä»¥åŠ ä¸Šæˆ‘ä»¬ä¹‹å‰çš„å„ç§ä¼˜åŒ–ç‚¹ï¼Œå¯¹bytebufferçš„æ‰©å®¹ã€å¯¹ç²˜åŒ…çš„å¤„ç†ï¼Œå¯¹å®¢æˆ·ç«¯å¼‚å¸¸å…³é—­æ­£å¸¸å…³é—­çš„å¤„ç†ç­‰ ä¼šè®©ä»£ç æ›´åŠ å®Œå–„ï¼Œä½†æ˜¯æˆ‘ä»¬è‡ªå·±å¤„ç†è¿˜æ˜¯ä¼šæœ‰å¾ˆå¤šé—®é¢˜ï¼Œæ¯”å¦‚nioæœ‰å¾ˆå¤šä»£ç å…¶å®æ˜¯ä¸€æ ·çš„ï¼Œè€Œä¸”è¿˜æœ‰ä¸€ä¸ªè‡­åæ˜­è‘—çš„ç©ºè½®è®­å¯¼è‡´cpuæ‰“æ»¡çš„é—®é¢˜ï¼Œæ‰€ä»¥æœ‰å¿…è¦å°è£…ä¸€å¥—é«˜æ€§èƒ½çš„ç½‘ç»œæ¡†æ¶æ¥å¤„ç†è¿™äº›é—®é¢˜ï¼Œä¹Ÿå°±æ˜¯å¤§åé¼é¼çš„netty

æ‰€ä»¥ä¸‹ä¸€ç¯‡,æˆ‘å°±æ¥ç®€å•ä»‹ç»ä¸‹nettyçš„ä½¿ç”¨ä»¥åŠåŸç†
