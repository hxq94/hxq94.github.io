---
title: 网络常用
thumbnail: /img/life/commands-round.png
cover: /img/life/commands.jpg
categories: 
- 常用命令
- 常用
top: 10
tags: 常用
# toc: true
---
一些网络零碎知识收集，最终可以汇聚成一篇大的文章
<!--more-->

> nginx-ingress-controller 开发地址
> https://github.com/kubernetes/ingress-nginx/blob/main/NEW_CONTRIBUTOR.md

### 常用命令
#### iptables
>  iptables -t nat -L PREROUTING -n
该命令用于查看 iptables NAT 表（-t nat）中 PREROUTING 链中的规则列表。具体的命令和输出可能会根据您的系统和规则而有所不同。

解释一下该命令的各个部分：

iptables: Linux 上用于配置 IP 包过滤规则的工具。
-t nat: 指定要操作的表为 NAT 表。
-L: 列出规则。
PREROUTING: 是 NAT 表中的一个链，它在数据包到达目标之前进行处理。
-n: 显示数字格式的 IP 地址和端口号，而不是通过 DNS 解析显示。
执行这个命令将输出 PREROUTING 链中的规则列表，这些规则用于修改数据包在到达目标之前的目的地。

```shell
iptables -t nat -L PREROUTING -n

# 输出类似下边
Chain PREROUTING (policy ACCEPT)
target     prot opt source               destination
DOCKER     all  --  0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL

KUBE-SVC   all  --  0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL
KUBE-FIREWALL  all  --  0.0.0.0/0            0.0.0.0/0            /* kubernetes firewall for dropping marked packets */ mark match 0x8000/0x8000

```

> iptables-save | grep PREROUTING
iptables-save 命令用于将 iptables 规则保存到标准输出

```shell
iptables-save | grep PREROUTING

这个命令的输出将显示包含 "PREROUTING" 的规则，其中可能包括 Docker、Kubernetes 或其他网络规则。示例输出可能如下所示：

-A PREROUTING -m addrtype --dst-type LOCAL -j DOCKER
-A PREROUTING -m addrtype --dst-type LOCAL -j KUBE-SVC
-A PREROUTING -m addrtype --dst-type LOCAL -j KUBE-FIREWALL

```

```shell
iptables -t nat -L KUBE-SERVICES -n | grep nginx
iptables -t nat -L KUBE-SERVICES -n | grep nginx 命令用于查看在 iptables NAT 表的 KUBE-SERVICES 链中是否存在与 "nginx" 相关的规则。
KUBE-SERVICES 是k8s用来管理service的流量入口的
```

```shell
iptables -t nat -L KUBE-SVC-2CMXP7HKUVJN7L6M -n

Chain KUBE-SVC-2CMXP7HKUVJN7L6M (2 references)
target     prot opt source               destination
KUBE-MARK-MASQ  tcp  -- !10.244.0.0/16        10.96.176.241        /* default/nginx cluster IP */ tcp dpt:80
KUBE-SEP-4IEO3WJHPKXV3AOH  all  --  0.0.0.0/0            0.0.0.0/0            /* default/nginx -> 10.244.0.5:80 */

```

 然后看一下每条链的详情
> 
 ```shell
iptables -t nat -L KUBE-MARK-MASQ -n

Chain KUBE-MARK-MASQ (31 references)
target     prot opt source               destination
MARK       all  --  0.0.0.0/0            0.0.0.0/0            MARK or 0x4000

这个通常是在响应外部网络请求的pod发回数据的时候，将数据包源ip地址转换为节点ip地址
 ```

```shell
iptables -t nat -L KUBE-SEP-4IEO3WJHPKXV3AOH -n

Chain KUBE-SEP-4IEO3WJHPKXV3AOH (1 references)
target     prot opt source               destination
KUBE-MARK-MASQ  all  --  10.244.0.5           0.0.0.0/0            /* default/nginx */
DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            /* default/nginx */ tcp to:10.244.0.5:80
```
> 这条命令返回的两个链条 其实一个是snat只不过是动态的，也就是从内部pod 10.244.0.5出来的流量 要走snat操作，以便能够出公网
> dnat意思是出公网后的流量需要流回原始pod 那么需要使用dnat这条规则 使得所有流回service ip且端口是80的流量都转换为目的地址为pod的地址
> 也就是10.244.0.5

### Masquerade 和SNAT区别 
Masquerade：

动态 IP 地址分配： Masquerade 通常用于动态地为内部网络上的主机分配一个外部 IP 地址。它会动态地选择外部 IP，通常是在连接建立时。这使得内部主机可以使用同一个外部 IP 地址进行出口通信。
适用于动态拨号连接： Masquerade 在动态拨号连接上很有用，因为它不需要提前配置用于 SNAT 的外部 IP 地址。

SNAT（Source NAT）：

静态 IP 地址分配： SNAT 通常用于静态地将内部 IP 地址映射到一个或多个预定义的外部 IP 地址。这种映射通常在配置时静态定义。
精确控制： SNAT 提供更精确的控制，因为您可以明确地指定要用于源地址转换的外部 IP 地址。
在 Kubernetes 中，SNAT 通常用于为 Pod 分配集群的外部 IP 地址，而 Masquerade 通常用于节点上的出口通信，尤其是在节点拥有动态 IP 地址或在拨号连接上的情况下。选择使用 Masquerade 还是 SNAT 取决于特定的网络需求和部署环境


```shell
iptables-save | grep 10.96.176.241

-A KUBE-SERVICES -d 10.96.176.241/32 -p tcp -m comment --comment "default/nginx cluster IP" -m tcp --dport 80 -j KUBE-SVC-2CMXP7HKUVJN7L6M
-A KUBE-SVC-2CMXP7HKUVJN7L6M ! -s 10.244.0.0/16 -d 10.96.176.241/32 -p tcp -m comment --comment "default/nginx cluster IP" -m tcp --dport 80 -j KUBE-MARK-MASQ

这里输入了和10.96.176.241 相关的ip地址的链条

第一个返回是说 满足目的地址是10.96.176.241/32 的tcp协议的  目的地端口是80的流量包 继续走  KUBE-SVC-2CMXP7HKUVJN7L6M 这个规则
第二条的返回（也就是KUBE-SVC-2CMXP7HKUVJN7L6M）是说源ip不在 10.244.0.0/16的数据包 且目的地是10.96.176.241/32 且目的端口是的80 的tcp流量包 跳向 KUBE-MARK-MASQ 这个条规则  这个规则在上面其实也说过了 ， 他的意思是 能够正确的进行nat转换，也就是pod请求完外边直之后，响应还能够正确的到达原始pod
```


### 关于网速

1Mbps = 1*1000*1000 bit位 
10000000bit / 8 = 125000kbyte/s = 125000/1024 kb = 125kb /1000 = 0.125MB 
